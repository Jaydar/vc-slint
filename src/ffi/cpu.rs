/* automatically generated by rust-bindgen 0.69.2 */

pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: u32 = 1;
pub const AV_CPU_FLAG_MMXEXT: u32 = 2;
pub const AV_CPU_FLAG_MMX2: u32 = 2;
pub const AV_CPU_FLAG_3DNOW: u32 = 4;
pub const AV_CPU_FLAG_SSE: u32 = 8;
pub const AV_CPU_FLAG_SSE2: u32 = 16;
pub const AV_CPU_FLAG_SSE2SLOW: u32 = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const AV_CPU_FLAG_SSE3: u32 = 64;
pub const AV_CPU_FLAG_SSE3SLOW: u32 = 536870912;
pub const AV_CPU_FLAG_SSSE3: u32 = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: u32 = 67108864;
pub const AV_CPU_FLAG_ATOM: u32 = 268435456;
pub const AV_CPU_FLAG_SSE4: u32 = 256;
pub const AV_CPU_FLAG_SSE42: u32 = 512;
pub const AV_CPU_FLAG_AESNI: u32 = 524288;
pub const AV_CPU_FLAG_AVX: u32 = 16384;
pub const AV_CPU_FLAG_AVXSLOW: u32 = 134217728;
pub const AV_CPU_FLAG_XOP: u32 = 1024;
pub const AV_CPU_FLAG_FMA4: u32 = 2048;
pub const AV_CPU_FLAG_CMOV: u32 = 4096;
pub const AV_CPU_FLAG_AVX2: u32 = 32768;
pub const AV_CPU_FLAG_FMA3: u32 = 65536;
pub const AV_CPU_FLAG_BMI1: u32 = 131072;
pub const AV_CPU_FLAG_BMI2: u32 = 262144;
pub const AV_CPU_FLAG_AVX512: u32 = 1048576;
pub const AV_CPU_FLAG_AVX512ICL: u32 = 2097152;
pub const AV_CPU_FLAG_SLOW_GATHER: u32 = 33554432;
pub const AV_CPU_FLAG_ALTIVEC: u32 = 1;
pub const AV_CPU_FLAG_VSX: u32 = 2;
pub const AV_CPU_FLAG_POWER8: u32 = 4;
pub const AV_CPU_FLAG_ARMV5TE: u32 = 1;
pub const AV_CPU_FLAG_ARMV6: u32 = 2;
pub const AV_CPU_FLAG_ARMV6T2: u32 = 4;
pub const AV_CPU_FLAG_VFP: u32 = 8;
pub const AV_CPU_FLAG_VFPV3: u32 = 16;
pub const AV_CPU_FLAG_NEON: u32 = 32;
pub const AV_CPU_FLAG_ARMV8: u32 = 64;
pub const AV_CPU_FLAG_VFP_VM: u32 = 128;
pub const AV_CPU_FLAG_DOTPROD: u32 = 256;
pub const AV_CPU_FLAG_I8MM: u32 = 512;
pub const AV_CPU_FLAG_SETEND: u32 = 65536;
pub const AV_CPU_FLAG_MMI: u32 = 1;
pub const AV_CPU_FLAG_MSA: u32 = 2;
pub const AV_CPU_FLAG_LSX: u32 = 1;
pub const AV_CPU_FLAG_LASX: u32 = 2;
pub const AV_CPU_FLAG_RVI: u32 = 1;
pub const AV_CPU_FLAG_RVF: u32 = 2;
pub const AV_CPU_FLAG_RVD: u32 = 4;
pub const AV_CPU_FLAG_RVV_I32: u32 = 8;
pub const AV_CPU_FLAG_RVV_F32: u32 = 16;
pub const AV_CPU_FLAG_RVV_I64: u32 = 32;
pub const AV_CPU_FLAG_RVV_F64: u32 = 64;
pub const AV_CPU_FLAG_RVB_BASIC: u32 = 128;
pub const AV_CPU_FLAG_RVB_ADDR: u32 = 256;
pub type wchar_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " Return the flags which specify extensions supported by the CPU.\n The returned value is affected by av_force_cpu_flags() if that was used\n before. So av_get_cpu_flags() can easily be used in an application to\n detect the enabled cpu flags."]
    pub fn av_get_cpu_flags() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disables cpu detection and forces the specified flags.\n -1 is a special case that disables forcing of specific flags."]
    pub fn av_force_cpu_flags(flags: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Parse CPU caps from a string and update the given AV_CPU_* flags based on that.\n\n @return negative on error."]
    pub fn av_parse_cpu_caps(
        flags: *mut ::std::os::raw::c_uint,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the number of logical CPU cores present."]
    pub fn av_cpu_count() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overrides cpu count detection and forces the specified count.\n Count < 1 disables forcing of specific count."]
    pub fn av_cpu_force_count(count: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the maximum data alignment that may be required by FFmpeg.\n\n Note that this is affected by the build configuration and the CPU flags mask,\n so e.g. if the CPU supports AVX, but libavutil has been built with\n --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through\n  av_set_cpu_flags_mask(), then this function will behave as if AVX is not\n  present."]
    pub fn av_cpu_max_align() -> usize;
}
